#!/usr/bin/env bash
#
# This builds a container for creating and renewing SSL certs in OpenShift
# project by utilizing Let's Encrypt certbot and NginX
#
# Mandatory Parameters:
#
# * EMAIL: passed to Let's Encrypt via certbot.
#
# Optional Parameters:
#
# * ROUTE_LABEL: as parameter to recognize which routes to setup SSL for.
# * CERTBOT_EXTRA_OPTS: passes additional parameters for certbot.
#   E.g. --test would be good while practising.
# * TRASH_ALL: deletes all /etc/letsencrypt contents. Used to force getting
#   new certs.
# * CERTBOT_SERVICE_NAME: certbot service name, defaults to certbot-ocp
#

set -o errexit
shopt -s expand_aliases

container=$(buildah from centos/nginx-18-centos7)
alias brc="buildah run --user root $container"

#
# Get oc command line client
#
file=$(mktemp oc-XXXX)
curl -sL https://github.com/openshift/origin/releases/download/v3.11.0/openshift-origin-client-tools-v3.11.0-0cbc58b-linux-64bit.tar.gz | \
  tar xz --to-stdout --warning=no-unknown-keyword -f - \
  openshift-origin-client-tools-v3.11.0-0cbc58b-linux-64bit/oc > \
  $file

buildah copy $container $file /bin/oc
rm $file
brc chmod +x /bin/oc

#
# Install certbot tool
#
brc yum install --quiet -y \
  https://dl.fedoraproject.org/pub/epel/7/x86_64/Packages/e/epel-release-7-12.noarch.rpm
brc yum install --quiet -y certbot
brc yum update --quiet -y
brc yum --quiet clean all

brc mkdir /var/log/letsencrypt
brc mkdir -p /opt/app-root/src/.well-known/acme-challenge
brc chmod -R g+rw /etc/letsencrypt /opt/app-root/src/.well-known \
    /var/log/letsencrypt /var/lib/letsencrypt

#
# create entrypoint starter script which starts nginx and runs certbot
#
file=$(mktemp start-XXXX)
cat > $file <<EOF
#!/bin/env bash
# start webserver
/opt/rh/rh-nginx18/root/usr/sbin/nginx

label="${ROUTE_LABEL:-letsencrypt-me=true}"
svcname="${CERTBOT_SERVICE_NAME:-certbot-ocp}"

if [ "\$TRASH_ALL" == "true" ]; then
  echo "delete all old certs"
  rm -rf /etc/letsencrypt/*
fi

# for all domains, do register
oc get routes -l \$label \
  -o custom-columns="name:.metadata.name, hostname:.spec.host" --no-headers \
  > /tmp/routes.txt
i=0
while read route; do
  echo \$route
  IFS=' ' read -ra ary <<< \$route
  echo "check if route for for \${ary[0]}-acme-challenge"
  if [ ! $(oc get route "\${ary[0]}-acme-challenge" &> /dev/null) ]; then
    echo "exposing service for \${ary[0]}-acme-challenge"
    oc expose service \$svcname \
      --path=/.well-known/acme-challenge \
      --port=8080 \
      --name="\${ary[0]}-acme-challenge" \
      -l 'certbot-ocp-delete-me-if-found-later=true' \
      --hostname=\${ary[1]}
    echo "return value of expose: \$?"
  fi
  echo check acme-challenge is up for: \${ary[0]},\${ary[1]}
  until [[ \$(curl --output /dev/null --silent --head --fail \
    http://\${ary[1]}/.well-known/acme-challenge/alive.html) ]] || \
    [[ \$i -eq 10 ]]; do
    printf '.'
    sleep 2
    i=\$((\$i+1))
  done
  if [ ! -d /etc/letsencrypt/live/\${ary[1]} ]; then
    echo asking for certs
    /usr/bin/certbot certonly --webroot -w /opt/app-root/src \
    --agree-tos -m \$EMAIL --deploy-hook /opt/app-root/patch.sh \
    -n \$CERTBOT_EXTRA_OPTS \
    -d \${ary[1]}
    echo result from certs: $?
  fi
done < /tmp/routes.txt

# renew all existing ones if needed
/usr/bin/certbot renew --deploy-hook /opt/app-root/patch.sh

oc delete route -l certbot-ocp-delete-me-if-found-later=true

EOF

buildah copy $container $file /opt/app-root/certs.sh
rm $file
brc chmod g+rx /opt/app-root/certs.sh

#
# do post hook for certbot that puts the certs and keys into routes
#
file=$(mktemp patch-XXXX)
cat > $file <<EOF
#!/bin/env bash
# just in case, get the renewed domains into array,
# even though we should only get one.
IFS=' ' read -ra fqdns <<< \$RENEWED_DOMAINS

CERT_FILE=\${RENEWED_LINEAGE}/cert.pem
CERTIFICATE="\$(awk '{printf "%s\\\\n", \$0}' \${CERT_FILE})"
KEY_FILE=\${RENEWED_LINEAGE}/privkey.pem
KEY="\$(awk '{printf "%s\\\\n", \$0}' \${KEY_FILE})"
CABUNDLE_FILE=\${RENEWED_LINEAGE}/fullchain.pem
CABUNDLE=\$(awk '{printf "%s\\\\n", \$0}' \${CABUNDLE_FILE})

# find out the ocp route name from the array of routes and their fqdn
while read route; do
  IFS=' ' read -ra ary <<< \$route
    if [[ "\${fqdns[0]}" == "\${ary[1]}" ]]; then
      ROUTE=\${ary[0]}
      break
    fi
done < /tmp/routes.txt

if [[ -n "\${ROUTE}" && -n "\${CERTIFICATE}" && -n "\${CABUNDLE}" ]]; then
  /usr/bin/oc patch "route/\${ROUTE}" \
   -p '{"spec":{"tls":{"certificate":"'"\${CERTIFICATE}"'", \
   "key":"'"\${KEY}"'", "caCertificate":"'"\${CABUNDLE}"'"}}}'
  expire_date=$(openssl x509 -in ${CERT_FILE} -noout -enddate | cut -d= -f 2)
  /usr/bin/oc patch "route/\${ROUTE}" \ 
   -p '{"metadata":{"annotations": \ 
   {"certbot-ocp/certiticate-expires":"'"\${expire_date}"'"}}}'
else
  echo "problem with one of the variables:"
  echo "route: \${ROUTE}"
  echo "certificate: \${CERTIFICATE}"
  echo "key:\${KEY}"
  echo "caCertificate: \${CABUNDLE}"
  exit 1
fi
EOF

buildah copy $container $file /opt/app-root/patch.sh
brc chmod g+rx /opt/app-root/patch.sh
rm $file

brc sh -c 'echo alive > /opt/app-root/src/.well-known/acme-challenge/alive.html'

buildah config --entrypoint /opt/app-root/certs.sh $container

buildah commit $container certbot-ocp:latest